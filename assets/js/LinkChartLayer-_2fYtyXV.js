import{fs as Ie,fq as Ee,fu as _e,fv as Se,aw as j,a_ as Le,s as V,e9 as Ae,fD as Re,V as E,e4 as U,cm as G,cN as H,dd as he,c6 as ze,_ as de,y as Me,fO as $e,fw as Fe,v as L,w as M,fB as Ge,x as Pe}from"./test-Dp3_P59c.js";import{I as K,E as Oe,D as Be,C as Ue,o as je,g as Qe,i as pe,a as Ve,b as We,c as qe,_ as He,P as Je,A as Ke,v as Xe,d as z,e as Ye,f as ee,u as ke}from"./KnowledgeGraphSublayer-C5EsMct9.js";import{u as J}from"./featureConversionUtils-BISEwGRc.js";import{_ as C,I as te,t as ae,S as A,o as Ze}from"./constants-B4mRqufT.js";import{u as et}from"./knowledgeGraphService-pMLlB5D4.js";import"./index-CulM0VMq.js";import"./vendor-CHjNVy30.js";import"./station-CTe-uNfl.js";import"./OptimizedFeature-99IiHQtf.js";import"./memoryEstimations-T_QTZf5l.js";import"./GraphQueryStreaming-5iEtxuCV.js";import"./FeatureStore-nrYqjidG.js";import"./BoundsStore-CMDWSQDA.js";import"./PooledRBush-QGhfJP2I.js";import"./timeSupport-CBFS3Cpf.js";import"./queryUtils-BylZ_vR4.js";import"./json-Wa8cmqdu.js";import"./optimizedFeatureQueryEngineAdapter-SquFTs-9.js";import"./QueryEngine-DobYVqGU.js";import"./WhereClauseCache-hvR0AHSq.js";import"./LRUCache--7okbBjw.js";import"./MemCache-CYsUaMUi.js";import"./WhereClause-RDKtpLzj.js";import"./TimeOnly-CSJYFsnz.js";import"./enum-DYiiI-Eb.js";import"./UnknownTimeZone-CD5-cTzw.js";import"./QueryEngineCapabilities-CsRUnGk7.js";import"./quantizationUtils-Cx-L7xZw.js";import"./utils-B1C6I_8d.js";import"./heatmapUtils-DD4QNsCV.js";import"./utils-Bcyv0ubY.js";import"./utils-Czy_3xGG.js";import"./ClassBreaksDefinition-DYQp9k4a.js";import"./SnappingCandidate-DGkpYqI6.js";import"./FixedIntervalBinParameters-CoCzclvP.js";import"./NormalizationBinParametersMixin-D7jY13wx.js";import"./FieldsIndex-dVB9L1ZQ.js";import"./clientSideDefaults-BGTRnQvd.js";import"./defaultsJSON-GKolV7NZ.js";import"./fieldProperties-B5lKbTPg.js";import"./labelingInfo-HpcBILMX.js";import"./SimpleRenderer-Cv_4-yU7.js";import"./commonProperties-Cz4LY7so.js";import"./colorRamps-B0gQZwFY.js";import"./ColorStop-Cu9MX0m5.js";import"./visualVariableUtils-CZtJQX17.js";import"./jsonUtils-C0_9DqtZ.js";import"./defaults3D-B9tjgcmU.js";import"./defaults-B2ew532g.js";import"./UniqueValueRenderer-U8EJ9Zmb.js";import"./diffUtils-CRH5h29A.js";import"./RendererLegendOptions-BX0ZTuxr.js";import"./styleUtils-B7fY0eUg.js";import"./labelUtils-BD42FNJJ.js";import"./DisplayFilteredLayer-NgY85tE-.js";import"./scaleUtils-BTu79So4.js";import"./displayFilterUtils-DEO713VP.js";import"./FeatureEffectLayer-26UFsVao.js";import"./FeatureEffect-CuBFMCn2.js";import"./FeatureFilter-Dp8Yy4C1.js";import"./FeatureReductionLayer-Dggj6XFo.js";import"./FeatureReductionSelection-D2_2kWu1.js";import"./jsonUtils-ckGU7SCY.js";import"./typeUtils-D_YGTMGu.js";import"./ClassBreaksRenderer-D8UibT1q.js";import"./DictionaryScriptEvaluator-BP8szh1a.js";import"./ArcadeExpression-Dcbbajtk.js";import"./utils-Bn4MiHWW.js";import"./defaultCIMValues-eS1WuCTt.js";import"./enums-DCdj6Lab.js";import"./OrderedLayer-D6-zNrUd.js";import"./OrderByInfo-BRAutEHC.js";import"./TemporalLayer-DVwyCMWq.js";import"./TimeInfo-BfXh-Eak.js";import"./FeatureSet-DR2_MLz0.js";import"./popupUtils-sYzRdAbr.js";import"./utils-GYScHLq5.js";import"./cimSymbolUtils-BwOwUl_r.js";import"./OptimizedFeatureSet-BR8EEvDc.js";import"./networkEnums-2v9fEE2p.js";import"./GPMessage-Bekmsege.js";var X;(function(e){e.MULTIPLIER="multiplier",e.ABSOLUTE="absolute-value"})(X||(X={}));let b=class extends Ie(Ee(_e(Se(Fe)))){constructor(e){if(super(e),this.url=null,this.dataPreloadedInLocalCache=!1,this.initializationLinkChartConfig=null,this.membershipModified=!0,this._currentLinkChartConfig={layoutMode:"organic-standard"},this._graphTypeLookup=new Map,this.dataManager=null,this.knowledgeGraph=null,this.layers=new(j.ofType(K)),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map,this.linkChartExtent=new Le({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.memberEntityTypes=null,this.memberRelationshipTypes=null,this.operationalLayerType="LinkChartLayer",this.sublayerIdsCache=new Map,this.tables=new(j.ofType(K)),this.type="link-chart",this.chronologicalAuxiliaryGraphics=null,this._originalInclusionList=e?.initializationInclusionModeDefinition,e?.dataPreloadedInLocalCache&&!e?.initializationInclusionModeDefinition)throw new V("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");this.addHandles(Ae((()=>this.layers.concat(this.tables)),((t,a)=>this._handleSublayersChange(t,a)),Re))}normalizeCtorArgs(e){if(!e)return{};const{url:t,title:a,dataPreloadedInLocalCache:n,initializationLinkChartConfig:i}=e;return{url:t,title:a,dataPreloadedInLocalCache:n,initializationLinkChartConfig:i}}_initializeLayerProperties(e){if(!this.title&&this.url){const o=this.url.split("/");this.title=o[o.length-2]}const t=new Set;let a=[],n=[];if(e.inclusionModeDefinition&&(!e.inclusionModeDefinition.namedTypeDefinitions||e.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new V("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");e.inclusionModeDefinition?.generateAllSublayers?(a=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]):e.inclusionModeDefinition?.namedTypeDefinitions&&e.inclusionModeDefinition?.namedTypeDefinitions.size>0?e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((o,r)=>{const h=this._graphTypeLookup.get(r);if(!h)return E.getLogger(this).warn(`A named type, ${r}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(r);h.type==="relationship"?t.has(r)||(t.add(r),n.push(h)):h.type==="entity"?t.has(r)||(t.add(r),a.push(h)):(E.getLogger(this).warn(`A named type, ${r}, was in the inclusion list that wasn't properly modeled and will be removed`),e.inclusionModeDefinition?.namedTypeDefinitions.delete(r))})):(a=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]);const i=new Oe({knowledgeGraph:e.knowledgeGraph,inclusionModeDefinition:e.inclusionModeDefinition});this.knowledgeGraph=e.knowledgeGraph,this.memberEntityTypes=a,this.memberRelationshipTypes=n,this.dataManager=i}load(e){const t=async()=>{const a=[],n=[];this.loadLayerAssumingLocalCache(),this._layersLoadedFromAuthoritativeItem()||await pe(this),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((i=>{i.useAllData=!1})),await this._initializeDiagram(),this.layers.forEach((i=>{n.push(i.refreshCachedQueryEngine()),a.push(new Promise((o=>{i.on("layerview-create",(()=>{o(null)}))})))})),this.tables.forEach((i=>{n.push(i.refreshCachedQueryEngine())})),await Promise.all(n)};return this.addResolvingPromise(new Promise((a=>{et(this.url).then((async n=>{n.dataModel.entityTypes?.forEach((o=>{o.name&&this._graphTypeLookup.set(o.name,o)})),n.dataModel.relationshipTypes?.forEach((o=>{o.name&&this._graphTypeLookup.set(o.name,o)}));const i=this.linkChart?.linkChartProperties;if(i?.originIdOf("entitiesUrl")===U.LINK_CHART&&(this.membershipModified=!1,this._originalInclusionList=await Be.fetchAndConvertSerializedLinkChart({entitiesUrl:i?.entitiesUrl,relationshipsUrl:i?.relationshipsUrl}),this._alignLayersDataModelAndInclusionDefinition(n.dataModel),this.initializationLinkChartConfig={layoutSettings:i?.layoutSettings??void 0,layoutMode:Ue(i.layoutType)}),this._initializeLayerProperties({knowledgeGraph:n,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((o=>{o.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(o.name,{useAllData:!0})})),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((o=>{o.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(o.name,{useAllData:!0})}))),this.dataPreloadedInLocalCache){const o=je.getInstance();for(const[r,h]of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions??[])for(const u of h.members?.values()??[]){const y=o.readFromStoreById(`${r}__${u.id}`);y&&G(this.dataManager.sublayerCaches,r,(()=>new Map)).set(u.id,y)}await t()}else{const o=this.initializationLinkChartConfig?.layoutMode==="geographic-organic-standard";this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,o,!0).then((async()=>{H(e),await t()})))}a(null)}))}))),Promise.resolve(this)}set initializationInclusionModeDefinition(e){this.loadStatus!=="loaded"&&this.loadStatus!=="failed"?this._set("initializationInclusionModeDefinition",e):E.getLogger(this).error("#initializationInclusionModeDefinition","initializationInclusionModeDefinition cannot be changed after the layer is loaded.")}get linkChart(){return this.parent}async addRecords(e,t){let a=[];t?.cascadeAddRelationshipEndNodes&&this.dataManager.knowledgeGraph.dataModel&&(a=await Qe(e,this.dataManager.knowledgeGraph));const n=e.concat(a).filter((i=>!this.sublayerIdsCache.get(i.typeName)?.has(i.id)));n.length>0&&(this.membershipModified=!0),await this._handleNewRecords(n,t)}async createSublayerForNamedType(e){await this.load();const t=this._graphTypeLookup.get(e);if(!t)throw new V("knowledge-graph:missing-type","The specified type does not exist in the knowledge graph.");if(this.dataManager.sublayerCaches.has(e))throw new V("knowledge-graph:duplicate-type","The specified type already exists as a sublayer.");this.dataManager.sublayerCaches.set(e,new Map),G(this.sublayerIdsCache,e,(()=>new Set));const a=this._createSublayer(t);return t.type==="entity"?this.dataManager.entityTypeNames.add(e):this.dataManager.relationshipTypeNames.add(e),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.set(e,{useAllData:!1,members:new Map}),a.geometryType?this.layers.push(a):this.tables.push(a),await pe(this,[e]),this._refreshNamedTypes(),a}async removeRecords(e,{cascadeRemoveRelationships:t=!0,recalculateLayout:a=!1,overrideMembershipCheck:n=!1}={cascadeRemoveRelationships:!0,recalculateLayout:!1,overrideMembershipCheck:!1}){let i=[];for(const h of e)(n||this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(h.typeName)?.useAllData===!1&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(h.typeName)?.members?.has(h.id))&&i.push(h);if(t){const h=new Set,u=[];for(const y of i)if(this.dataManager.nodeConnectionsLookup.has(y.id))for(const m of this.dataManager.nodeConnectionsLookup.get(y.id))h.add(m);for(const y of h)if(this.dataManager.memberIdTypeLookup.has(y))for(const m of this.dataManager.memberIdTypeLookup.get(y))this.dataManager.relationshipTypeNames.has(m)&&u.push({id:y,typeName:m});i=i.concat(u)}this.dataManager.removeFromLayer(i);for(const h of i)this.sublayerIdsCache.get(h.typeName)?.delete(h.id),this.dataManager.relationshipTypeNames.has(h.typeName)?this.relationshipLinkChartDiagramLookup.delete(h.id):this.entityLinkChartDiagramLookup.delete(h.id);const o=a?void 0:this.getCurrentNodeLocations();await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode,{layoutSettings:this._currentLinkChartConfig.layoutSettings,lockedNodeLocations:o}),i.length>0&&(this.membershipModified=!0);const r=[];return this.layers.forEach((h=>{r.push(h.refreshCachedQueryEngine())})),await Promise.all(r),this._refreshNamedTypes(),i}async expand(e,t){let a=[];try{const n=await this.dataManager.getConnectedRecordIds(e,t?.relationshipTypeNames,t);a=n.filter((i=>!this.sublayerIdsCache.get(i.typeName)?.has(i.id))),await this._handleNewRecords(a,t),n.length>0&&(this.membershipModified=!0),H(t?.signal)}catch(n){throw he(n)&&a.length>0&&await this.removeRecords(a,{overrideMembershipCheck:!0}),n}return{records:a}}loadLayerAssumingLocalCache(){const e=[...this.memberRelationshipTypes,...this.memberEntityTypes];this.layers.length||this.originIdOf("tables")===U.DEFAULTS?this.originIdOf("layers")===U.DEFAULTS?this._createSublayers(e,this.layers,(t=>!!t.geometryType)):this._updateSublayers(e,this.layers):this.layers=new j,this.tables.length||this.originIdOf("layers")===U.DEFAULTS?this.originIdOf("tables")===U.DEFAULTS?this._createSublayers(e,this.tables,(t=>!t.geometryType)):this._updateSublayers(e,this.tables):this.tables=new j,this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((t,a)=>{const n=G(this.sublayerIdsCache,a,(()=>new Set));t.members?.forEach((({id:i,linkChartLocation:o})=>{if(n.add(i),o){const r="coords"in o&&"lengths"in o?o:J(o);this.dataManager.relationshipTypeNames.has(a)?this.relationshipLinkChartDiagramLookup.set(i,r):this.entityLinkChartDiagramLookup.set(i,r)}}))}))}async calculateLinkChartLayout(e="organic-standard",t){const a=[],n=[],i=[];this.dataManager.sublayerCaches.forEach(((s,d)=>{this.dataManager.entityTypeNames.has(d)?s.forEach((l=>{a.push({typeName:d,feature:l})})):this.dataManager.relationshipTypeNames.has(d)&&s.forEach((l=>{n.push({typeName:d,feature:l})}))})),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map;const o=new Map,r=new Map,h=new Map,u=new Map,y=new Uint8Array(a.length),m=new Float64Array(a.length),w=new Float64Array(a.length),Q=new Float64Array(a.length),S=new Float64Array(a.length),T=new Uint32Array(n.length),ie=new Uint32Array(n.length),ue=new Float64Array(n.length),ce=new Float64Array(n.length),g=[],Ce="organic-standard";let ye=!1;const N=new Le({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let P,me="organic-standard",c=0,v=0;const Te=Ve.apply;switch(me=e==="geographic-organic-standard"?Ce:e,me){case"organic-standard":P=Xe.apply;break;case"organic-community":P=Ke.apply;break;case"hierarchical-bottom-to-top":P=Je.apply;break;case"radial-root-centric":P=He.apply;break;case"tree-left-to-right":P=qe.apply;break;default:P=We.apply}let ne=!1;a.forEach((({typeName:s,feature:d})=>{if(e!=="chronological-mono-timeline"&&e!=="chronological-multi-timeline"&&t?.lockedNodeLocations?.has(d.attributes[C])){e==="geographic-organic-standard"&&this.dataManager.geographicLookup.has(s)?y[c]=z.IsGeographic:y[c]=z.None;const l=t.lockedNodeLocations.get(d.attributes[C]);m[c]=l.x,w[c]=l.y}else if(e==="geographic-organic-standard"&&this.dataManager.geographicLookup.has(s)){y[c]=z.IsGeographic;let l=null;const k=d.attributes[this.dataManager.geographicLookup.get(s).name];switch(this.dataManager.geographicLookup.get(s)?.geometryType){case"esriGeometryPoint":m[c]=k?.x,w[c]=k?.y;break;case"esriGeometryPolygon":l=k?.centroid,l?.x!=null&&l?.y!=null?(m[c]=l.x,w[c]=l.y):y[c]=z.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":l=k?.extent?.center,l?.x!=null&&l?.y!=null?(m[c]=l.x,w[c]=l.y):y[c]=z.IsMovable;break;default:y[c]=z.IsMovable}(m[c]==null||w[c]==null||Number.isNaN(m[c])||Number.isNaN(w[c]))&&(y[c]=z.IsMovable,m[c]=0,w[c]=0)}else if(e==="chronological-mono-timeline"||e==="chronological-multi-timeline"){!ne&&t?.lockedNodeLocations?.has(d.attributes[C])&&(ne=!0);const l=t?.timeInfoByTypeName?.get(s),k=l?.startField,D=k&&l?.startField?d.attributes[k]:null;Q[c]=D?new Date(D).getTime():NaN;const f=l?.endField,I=f&&l?.endField?d.attributes[f]:null;S[c]=I?new Date(I).getTime():NaN,m[c]=0,w[c]=0,y[c]=z.IsMovable}else y[c]=z.IsMovable,m[c]=0,w[c]=0;u.set(d.attributes[C],c),g[c]={feature:d,typeName:s},c++})),ne&&E.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");let ge=!1;const oe=new Map;n.forEach((s=>{const d=s.feature.attributes[te],l=s.feature.attributes[ae],k=u.get(d),D=u.get(l),f=t?.timeInfoByTypeName?.get(s.typeName),I=t?.timeInfoByTypeName?f?.startField:null,R=I?s.feature.attributes[I]:null,Z=f?.endField,O=Z?s.feature.attributes[Z]:null;if(k!==void 0&&D!==void 0){let $=d+"-"+l;e!=="chronological-mono-timeline"&&e!=="chronological-multi-timeline"||($=$+"-"+R+"-"+O);const q=oe.get($);q?.has(s.typeName)||(T[v]=k,ie[v]=D,e!=="chronological-mono-timeline"&&e!=="chronological-multi-timeline"||(ue[v]=R?new Date(R).getTime():NaN,ce[v]=O?new Date(O).getTime():NaN),q===void 0?oe.set($,new Map([[s.typeName,v]])):q.set(s.typeName,v),v++),i.push(s)}else ge=!0,this.relationshipLinkChartDiagramLookup.set(d,null)})),ge&&E.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");const Ne=this._validateOrganicLayoutSettings(e,t?.layoutSettings?.organicLayoutSettings),se=this._convertValidatedOrganicSettingsToCalculationSettings(Ne);await Ye();let W=ee.Error,x=null;if(e==="chronological-mono-timeline"||e==="chronological-multi-timeline"){let s;({status:W,links:x,graphics:s}=Te((()=>t?.signal?.aborted??!1),y,m,w,Q,S,T.subarray(0,v),ie.subarray(0,v),ue.subarray(0,v),ce.subarray(0,v),e==="chronological-multi-timeline",t?.layoutSettings?.chronologicalLayoutSettings)),W===ee.Success&&(this.chronologicalAuxiliaryGraphics=s)}else({status:W,links:x}=P((()=>t?.signal?.aborted??!1),y,m,w,T.subarray(0,v),ie.subarray(0,v),se.computationBudgetTime,se.idealEdgeLengthMultiplier,se.repulsionRadiusMultiplier));if(H(t?.signal),W===ee.Error)throw new V("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");if(W===ee.Canceled)throw ze();for(let s=0;s<g.length;s++){if(w[s]>84.9999?w[s]=84.9999:w[s]<-84.9999&&(w[s]=-84.9999),m[s]>179.9999?m[s]=179.9999:m[s]<-179.9999&&(m[s]=-179.9999),g[s].feature.attributes[A]=new de(m[s],w[s]),o.has(g[s].typeName))o.get(g[s].typeName)?.set(g[s].feature.attributes[C],g[s].feature);else{const f=new Map;f.set(g[s].feature.attributes[C],g[s].feature),o.set(g[s].typeName,f)}h.set(g[s].feature.attributes[C],g[s].feature);const d=J(g[s].feature.attributes[A]);this.entityLinkChartDiagramLookup.set(g[s].feature.attributes[C],g[s].feature.attributes[A]?d:null);const l=G(this.dataManager.inclusionModeDefinition.namedTypeDefinitions,g[s].typeName,(()=>({useAllData:!1,members:new Map})));G(l.members,g[s].feature.attributes[C],(()=>({id:g[s].feature.attributes[C],linkChartLocation:void 0}))).linkChartLocation=g[s].feature.attributes[A];const{x:k,y:D}=g[s].feature.attributes[A];ye?(N.xmin=Math.min(N.xmin,k),N.xmax=Math.max(N.xmax,k),N.ymin=Math.min(N.ymin,D),N.ymax=Math.max(N.ymax,D)):(N.xmin=k-1e-7,N.xmax=k+1e-7,N.ymin=D-1e-7,N.ymax=D+1e-7,ye=!0)}if(this.linkChartExtent.xmin=N.xmin,this.linkChartExtent.xmax=N.xmax,this.linkChartExtent.ymin=N.ymin,this.linkChartExtent.ymax=N.ymax,!x)throw new V("knowledge-graph:layout-failed","Attempting to retrieve link geometry from diagram engine failed");const Y=new Map,re=new Map,le=new Map,fe=new Set;for(let s=0;s<i.length;s++){const d=[],l=i[s],k=l.feature.attributes[te],D=l.feature.attributes[ae];let f=k+"-"+D;if(e==="chronological-mono-timeline"||e==="chronological-multi-timeline"){const p=t?.timeInfoByTypeName?.get(l.typeName),_=t?.timeInfoByTypeName?p?.startField:null,F=_?l.feature.attributes[_]:null,B=p?.endField;f+="-"+F+"-"+(B?l.feature.attributes[B]:null)}const I=oe.get(f).get(l.typeName),R=I===0?0:x?.vertexEndIndex[I-1];if(!fe.has(I)){if(fe.add(I),x.types[I]===ke.Recursive){const p=[x.vertices[2*R],x.vertices[2*R+1]],_=[x.vertices[2*(R+1)],x.vertices[2*(R+1)+1]],F=[.5*(p[0]+_[0]),.5*(p[1]+_[1])],B=[F[0]-p[0],F[1]-p[1]],ve=[F[0]+B[1],F[1]-B[0]],xe=[F[0]-B[1],F[1]+B[0]];d.push(p),d.push(ve),d.push(_),d.push(xe),d.push(p)}else{if(x.types[I]!==ke.Regular){E.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");continue}for(let p=R;p<x.vertexEndIndex[I];p++)d.push([x.vertices[2*p],x.vertices[2*p+1]])}if(e!=="chronological-mono-timeline"&&e!=="chronological-multi-timeline"){const p=g[u.get(k)]?.feature.attributes[A],_=g[u.get(D)]?.feature.attributes[A];d[0][0]===p.x&&d[0][1]===p.y||(d[0]=[p.x,p.y]),d[d.length-1][0]===_.x&&d[d.length-1][1]===_.y||(d[d.length-1]=[_.x,_.y])}for(let p=1;p<d.length-1;p++)d[p][1]>85.5?d[p][1]=85.5:d[p][1]<-85.5&&(d[p][1]=-85.5),d[p][0]>179.9999?d[p][0]=179.9999:d[p][0]<-179.9999&&(d[p][0]=-179.9999);Y.has(f)?Y.get(f).push(d):Y.set(f,[d])}const Z=Y.get(f);re.has(f)||(re.set(f,new Map),le.set(f,new Map));const O=re.get(f),$=le.get(f);O.has(l.typeName)||(O.set(l.typeName,Z.shift()),$.set(l.typeName,0));const q=O.get(l.typeName);$.set(l.typeName,$.get(l.typeName)+1);const be=new Me({paths:[q]});if(l.feature.attributes[A]=be,r.has(l.typeName))r.get(l.typeName)?.set(l.feature.attributes[C],l.feature);else{const p=new Map;p.set(l.feature.attributes[C],l.feature),r.set(l.typeName,p)}h.set(l.feature.attributes[C],l.feature);const we=J(l.feature.attributes[A]);this.relationshipLinkChartDiagramLookup.set(l.feature.attributes[C],l.feature.attributes[A]?we:null);const De=G(this.dataManager.inclusionModeDefinition.namedTypeDefinitions,l.typeName,(()=>({useAllData:!1,members:new Map})));G(De.members,l.feature.attributes[C],(()=>({id:l.feature.attributes[C],linkChartLocation:void 0}))).linkChartLocation=we}for(const s of i)s.feature.attributes[Ze]=le.get(s.feature.attributes[te]+"-"+s.feature.attributes[ae])?.get(s.typeName)??null;return this._currentLinkChartConfig={layoutMode:e,layoutSettings:t?.layoutSettings?.clone()},{nodes:o,links:r,idMap:h}}async applyNewLinkChartLayout(e="organic-standard",t){const a=[];await this._calculateLayoutWithSublayerTimeInfo(e,t),this.layers.forEach((n=>{a.push(n.refreshCachedQueryEngine())})),this.membershipModified=!0,await Promise.all(a),this._refreshNamedTypes()}getCurrentNodeLocations(){const e=new Map;for(const[t,a]of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.entries()??[])this.dataManager.relationshipTypeNames.has(t)||a?.members?.forEach((n=>{const i=n.linkChartLocation;let o;const r=n.id;i&&(o="x"in i?{x:i.x,y:i.y}:{x:i.coords[0],y:i.coords[1]},e.set(r,new de({x:o.x,y:o.y})))}));return e}async refreshLinkChartCache(e){await this.dataManager.refreshCacheContent(e);const t=[];this.layers.forEach((a=>{t.push(a.refreshCachedQueryEngine())})),await Promise.all(t),this._refreshNamedTypes()}async connectBetweenEntities(e,t){if(!e.length)return{records:[]};let a=[];try{let n=[];for(const i of this.dataManager.relationshipTypeNames){const o=this.sublayerIdsCache.get(i);o&&(n=n.concat(Array.from(o.keys())))}a=await this.dataManager.getRelationshipsBetweenNodes(e,n,t),await this._handleNewRecords(a,t),H(t)}catch(n){throw he(n)&&this.removeRecords(a),n}return{records:a}}async connectFromEntities(e,t){if(!e.length)return{records:[]};let a=[];try{let n=[];for(const o of this.dataManager.relationshipTypeNames){const r=this.sublayerIdsCache.get(o);r&&(n=n.concat(Array.from(r.keys())))}let i=[];for(const o of this.dataManager.entityTypeNames){const r=this.sublayerIdsCache.get(o);r&&(i=i.concat(Array.from(r)))}a=await this.dataManager.getRelationshipsFromNodes(e,i,n,t),await this._handleNewRecords(a,t),a.length>0&&(this.membershipModified=!0),H(t)}catch(n){throw he(n)&&this.removeRecords(a),n}return{records:a}}getCurrentLayout(){return this._currentLinkChartConfig.layoutMode}async _calculateLayoutWithSublayerTimeInfo(e="organic-standard",t){const a=new Map;this.layers.forEach((n=>{a.set(n.objectType.name,n.timeInfo)})),await this.calculateLinkChartLayout(e,{timeInfoByTypeName:a,...t}),this.linkChart?.handleChronologicalOverlay()}async _handleNewRecords(e,t){const a=new Set,n=[],i=this.layers.concat(this.tables);for(const r of e)this._graphTypeLookup.has(r.typeName)&&(i.some((h=>h.objectType.name===r.typeName))===!1&&(this.dataManager.sublayerCaches.set(r.typeName,new Map),a.add(r.typeName)),G(this.sublayerIdsCache,r.typeName,(()=>new Set)).add(r.id),n.push(r));this.dataManager.addToLayer(n);for(const r of a){const h=this._graphTypeLookup.get(r);if(h){const u=this._createSublayer(h);h.type==="entity"?this.dataManager.entityTypeNames.add(r):this.dataManager.relationshipTypeNames.add(r),u.geometryType?this.layers.push(u):this.tables.push(u)}}await pe(this,Array.from(a),t),await this.dataManager.refreshCacheContent(e.map((r=>r.id)),void 0,void 0,void 0,t);const o={layoutSettings:this._currentLinkChartConfig.layoutSettings,lockedNodeLocations:new Map};for(const[r,h]of this.entityLinkChartDiagramLookup.entries())h&&o.lockedNodeLocations.set(r,new de(h.coords[0],h.coords[1]));await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode,o)}_createSublayers(e,t,a){e.forEach((n=>{const i=this._createSublayer(n);a(i)&&t.push(i),this._updateSublayerCaches(n)}))}_updateSublayers(e,t){t.forEach((a=>{a.parentCompositeLayer=this;const n=e.find((i=>i.type===a.graphType&&i.name===a.graphTypeName));n&&(a.objectType=n,a.read({title:n.name},{origin:"service"}),this._updateSublayerCaches(n))}))}_updateSublayerCaches({name:e}){if(!e)return;const t=this.dataManager.sublayerCaches;t.has(e)||t.set(e,new Map)}_layersLoadedFromAuthoritativeItem(){const e=this.originIdOf("layers");return e>=U.PORTAL_ITEM&&e<U.USER}async _initializeDiagram(){this.initializationLinkChartConfig?this.initializationLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e,t)=>{e?.members?.forEach((a=>{const n=a.linkChartLocation;let i;const o=a.id;if(!n)return;i="x"in n?{x:n.x,y:n.y}:{x:n.coords[0],y:n.coords[1]};const r=J(i);this.dataManager.relationshipTypeNames.has(t)?this.relationshipLinkChartDiagramLookup.set(o,r):this.entityLinkChartDiagramLookup.set(o,r),this.linkChartExtent.xmin>i.x&&(this.linkChartExtent.xmin=i.x),this.linkChartExtent.xmax<i.x&&(this.linkChartExtent.xmax=i.x),this.linkChartExtent.ymin>i.y&&(this.linkChartExtent.ymin=i.y),this.linkChartExtent.ymax<i.y&&(this.linkChartExtent.ymax=i.y)}))})),this.memberRelationshipTypes.forEach((e=>{e.name&&this.dataManager.sublayerCaches.get(e.name)?.forEach((t=>{const a=this.relationshipLinkChartDiagramLookup.get(t.attributes[te]),n=this.relationshipLinkChartDiagramLookup.get(t.attributes[ae]);if(a&&n){const i=J(new Me({paths:[[[a.coords[0],a.coords[1]],[n.coords[0],n.coords[1]]]]}));this.relationshipLinkChartDiagramLookup.set(t.attributes[C],i)}else this.relationshipLinkChartDiagramLookup.set(t.attributes[C],null)}))}))):await this._calculateLayoutWithSublayerTimeInfo(this.initializationLinkChartConfig.layoutMode,{lockedNodeLocations:this.getCurrentNodeLocations(),...this.initializationLinkChartConfig||{}}):await this._calculateLayoutWithSublayerTimeInfo("organic-standard",{lockedNodeLocations:this.getCurrentNodeLocations()})}_refreshNamedTypes(){for(const e of this.layers)e.emit("refresh",{dataChanged:!0});for(const e of this.tables)e.emit("refresh",{dataChanged:!0})}_validateOrganicLayoutSettings(e,t){const a=T=>typeof T=="number"&&!isNaN(T),n=T=>a(T)&&T>=1,i=T=>a(T)&&T>=1,o=T=>Object.values(X).includes(T),r=T=>a(T)&&T>=0,h={};if(!new Set(["organic-standard","organic-community","geographic-organic-standard","chronological-multi-timeline","chronological-mono-timeline"]).has(e)||!t)return h;const{computationBudgetTime:u,autoRepulsionRadius:y,repulsionRadiusMultiplier:m,absoluteIdealEdgeLength:w,multiplicativeIdealEdgeLength:Q,idealEdgeLengthType:S}=t;return i(u)?h.computationBudgetTime=u:u&&E.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"),h.autoRepulsionRadius=y,!y&&n(m)?h.repulsionRadiusMultiplier=m:y||(h.autoRepulsionRadius=!0,E.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting")),e==="geographic-organic-standard"&&(o(S)?h.idealEdgeLengthType=S:S!==void 0&&E.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'),S==="absolute-value"&&r(w)?h.absoluteIdealEdgeLength=w:S==="absolute-value"&&w!==void 0?E.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting"):S==="multiplier"&&r(Q)?h.multiplicativeIdealEdgeLength=Q:S==="multiplier"&&Q!==void 0&&E.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")),h}_convertValidatedOrganicSettingsToCalculationSettings(e){let t=e.idealEdgeLengthType===X.ABSOLUTE?e.absoluteIdealEdgeLength:e.multiplicativeIdealEdgeLength;return e.idealEdgeLengthType===X.ABSOLUTE&&(t===void 0?t=-1:t*=-1),{computationBudgetTime:e.computationBudgetTime??void 0,repulsionRadiusMultiplier:e.repulsionRadiusMultiplier&&!e.autoRepulsionRadius?e.repulsionRadiusMultiplier:void 0,idealEdgeLengthMultiplier:t}}_createSublayer(e){return new K({objectType:e,parentCompositeLayer:this,graphType:e.type})}_handleSublayersChange(e,t){t&&(t.forEach((a=>{a.parent=null})),this.removeHandles("sublayers-owner")),e&&(e.forEach((a=>{a.parent=this})),this.addHandles([e.on("after-add",(({item:a})=>{a.parent=this})),e.on("after-remove",(({item:a})=>{a.parent=null}))],"sublayers-owner"))}_alignLayersDataModelAndInclusionDefinition(e){const t=new Set((e.entityTypes??[]).map((i=>i.name)).concat((e.relationshipTypes??[]).map((i=>i.name)))),a=new Set((e.entityTypes??[]).map((i=>i.name))),n=new Set((e.relationshipTypes??[]).map((i=>i.name)));if(this.layers){for(const o of this.layers)!o.graphType&&t.has(o.graphTypeName)&&(o.graphType=a.has(o.graphTypeName)?"entity":"relationship");const i=this.layers.filter((o=>t.has(o.graphTypeName)&&(o.graphType==="entity"?a.has(o.graphTypeName):n.has(o.graphTypeName))));this.setAtOrigin("layers",i,$e(this.originIdOf("layers")))}else this.layers=new j;if(this.layers&&this._originalInclusionList){const i=new Set(this._originalInclusionList.namedTypeDefinitions.keys()),o=this.tables?.map((u=>u.graphTypeName))??[],r=this.layers.map((u=>u.graphTypeName)).concat(o);for(const u of r)i.has(u)||this._originalInclusionList.namedTypeDefinitions.set(u,{useAllData:!1,members:new Map});const h=[];for(const u of this._originalInclusionList.namedTypeDefinitions.keys())r.includes(u)||(E.getLogger(this).warn(`A named type, ${u}, was in the serialized feature collection but did not have a sublayer config in the item, so will be removed`),h.push(u));for(const u of h)this._originalInclusionList.namedTypeDefinitions.delete(u)}}};L([M(Ge)],b.prototype,"url",void 0),L([M()],b.prototype,"dataPreloadedInLocalCache",void 0),L([M()],b.prototype,"initializationLinkChartConfig",void 0),L([M()],b.prototype,"membershipModified",void 0),L([M()],b.prototype,"dataManager",void 0),L([M()],b.prototype,"initializationInclusionModeDefinition",null),L([M()],b.prototype,"knowledgeGraph",void 0),L([M({type:j.ofType(K),json:{write:{ignoreOrigin:!0}}})],b.prototype,"layers",void 0),L([M({readOnly:!0})],b.prototype,"linkChart",null),L([M()],b.prototype,"entityLinkChartDiagramLookup",void 0),L([M()],b.prototype,"relationshipLinkChartDiagramLookup",void 0),L([M()],b.prototype,"linkChartExtent",void 0),L([M()],b.prototype,"memberEntityTypes",void 0),L([M()],b.prototype,"memberRelationshipTypes",void 0),L([M({type:["LinkChartLayer"]})],b.prototype,"operationalLayerType",void 0),L([M()],b.prototype,"sublayerIdsCache",void 0),L([M({type:j.ofType(K),json:{write:{ignoreOrigin:!0}}})],b.prototype,"tables",void 0),L([M({json:{read:!1}})],b.prototype,"type",void 0),L([M({json:{read:!1}})],b.prototype,"chronologicalAuxiliaryGraphics",void 0),b=L([Pe("esri.layers.LinkChartLayer")],b);const xa=b;export{xa as default};
