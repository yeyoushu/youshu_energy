const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/js/ProjectionTransformation-C91QiveH.js","assets/js/Envelope2D-Co2MCTM2.js","assets/js/Point2D-COgQ1fyf.js","assets/js/Transformation2D-BGxYmbTi.js","assets/js/SimpleGeometryCursor-B92kdZ15.js","assets/js/test-Dp3_P59c.js","assets/js/index-CulM0VMq.js","assets/js/vendor-CHjNVy30.js","assets/css/index-DXVkK3IA.css","assets/js/station-CTe-uNfl.js","assets/css/test-D2ol9zJk.css","assets/js/OperatorDefinitions-DP7_WWTp.js","assets/js/apiConverter-B77FyzsP.js","assets/js/jsonConverter-CA3f99zM.js"])))=>i.map(i=>d[i]);
import{a as c}from"./index-CulM0VMq.js";import{s as A}from"./SimpleGeometryCursor-B92kdZ15.js";import{f1 as O,f2 as R,f3 as w}from"./test-Dp3_P59c.js";import"./vendor-CHjNVy30.js";import"./station-CTe-uNfl.js";let u;function E(){return!!u&&w()}async function g(){if(!E()){const[r,n]=await Promise.all([c(()=>import("./ProjectionTransformation-C91QiveH.js").then(t=>t.aV),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])).then((t=>t.aH)),c(()=>import("./ProjectionTransformation-C91QiveH.js").then(t=>t.aV),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])).then((t=>t.aG)).then((({injectPe:t})=>t)),O()]);u=new r.OperatorProject,n(R)}}function y(r,n){return u.execute(r,n,null)}function D(r,n){const t=u.executeMany(new A(r),n,null);return Array.from(t)}function L(){return u.supportsCurves()}let h,f,m,p,_,d,T,v,x,I,P,F;function $(){return!!f&&E()}async function C(){if(!$()){const[r,n,t,o]=await Promise.all([c(()=>import("./apiConverter-B77FyzsP.js"),__vite__mapDeps([12,2,1,0,3,4,5,6,7,8,9,10,11,13])),c(()=>import("./ProjectionTransformation-C91QiveH.js").then(e=>e.aV),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])).then((e=>e.aI)).then((({CompositeGeographicTransformationEditor:e})=>e)),c(()=>import("./ProjectionTransformation-C91QiveH.js").then(e=>e.aV),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])).then((e=>e.aJ)).then((({create:e,createFromWKT:a})=>({create:e,createFromWKT:a}))),c(()=>import("./ProjectionTransformation-C91QiveH.js").then(e=>e.aV),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])).then((e=>e.aK)).then((({create:e,createEx:a,createFromAoi:i})=>({create:e,createEx:a,createFromAoi:i}))),g()]);h=r.fromExtent,f=r.fromGeometry,m=r.fromSpatialReference,p=r.getSpatialReference,_=r.toGeometry,d=n,T=t.create,v=t.createFromWKT,x=o.createEx,I=o.createFromAoi,P=o.create,F=L()}}function W(r,n,t={}){const o=V(p(r),n,t);return _(y(f(r),o),n)}function M(r,n,t={}){const o=r.map(f),e=V(p(r),n,t);return D(o,e).map((a=>_(a,n)))}function V(r,n,t={}){let o;const e=m(r),a=m(n);if(t?.geographicTransformation){const i=new d;i.setInputSpatialReference(e),i.setOutputSpatialReference(a);for(const s of t.geographicTransformation.steps){let l;l=s.wkid?T(s.wkid,s.isInverse):v(s.wkt,s.isInverse),i.add(l)}o=i.create()}else if(t?.areaOfInterestExtent)return I(e,a,h(t.areaOfInterestExtent).asEnvelope2D());return o?x(e,a,o):P(e,a)}export{W as execute,M as executeMany,$ as isLoaded,C as load,F as supportsCurves};
