import{j6 as I}from"./test-DMnSxVQs.js";import{z as $,A as B,B as H,C as T,D as z,G as P,H as L,I as W,J as G,K as v}from"./vendor-CHjNVy30.js";import{g as _}from"./dom-BpLKpeVb.js";import{d as J}from"./debounce-D0Dr7phT.js";function K(t){return V(t)}function p(t){return t.assignedSlot?t.assignedSlot:t.parentNode instanceof ShadowRoot?t.parentNode.host:t.parentNode}function V(t){for(let e=t;e;e=p(e))if(e instanceof Element&&getComputedStyle(e).display==="none")return null;for(let e=p(t);e;e=p(e)){if(!(e instanceof Element))continue;const n=getComputedStyle(e);if(n.display!=="contents"&&(n.position!=="static"||$(n)||e.tagName==="BODY"))return e}return null}/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */(function(){{const e=v.getOffsetParent;v.getOffsetParent=n=>e(n,K)}})();function S(t){const e=window.devicePixelRatio||1;return Math.round(t*e)/e}const U=(async(t,{referenceEl:e,floatingEl:n,overlayPositioning:a="absolute",placement:i,flipDisabled:s,flipPlacements:r,offsetDistance:o,offsetSkidding:x,arrowEl:d,type:A})=>{if(!e||!n)return;const m=_(n)==="rtl",{x:D,y:R,placement:b,strategy:C,middlewareData:g}=await H(e,n,{strategy:a,placement:i==="auto"||i==="auto-start"||i==="auto-end"?void 0:w(i,m),middleware:q({placement:i,flipDisabled:s,flipPlacements:r?.map(c=>w(c,m)),offsetDistance:o,offsetSkidding:x,arrowEl:d,type:A})});if(d&&g.arrow){const{x:c,y:k}=g.arrow,f=b.split("-")[0],h=c!=null?"left":"top",N=Z[f],j={left:"",top:"",bottom:"",right:""};"floatingLayout"in t&&(t.floatingLayout=f==="left"||f==="right"?"horizontal":"vertical"),Object.assign(d.style,{...j,[h]:`${h=="left"?c:k}px`,[f]:"100%",transform:N})}const y=g.hide?.referenceHidden?"hidden":null,E=y?"none":null;n.setAttribute(Y,b),Object.assign(n.style,{pointerEvents:E,position:C,transform:`translate(${S(D)}px,${S(R)}px)`,visibility:y})}),Y="data-placement",O=["top","bottom","right","left","top-start","top-end","bottom-start","bottom-end","right-start","right-end","left-start","left-end","leading","trailing","leading-start","leading-end","trailing-start","trailing-end"],rt="bottom-start",lt="bottom-end",ct={animation:"calcite-floating-ui-anim",animationActive:"calcite-floating-ui-anim--active"};function q({placement:t,flipDisabled:e,flipPlacements:n,offsetDistance:a,offsetSkidding:i,arrowEl:s,type:r}){const o=[T(),z()];return r==="menu"&&o.push(P({fallbackPlacements:n||["top-start","top","top-end","bottom-start","bottom","bottom-end"]})),o.push(L({mainAxis:typeof a=="number"?a:0,crossAxis:typeof i=="number"?i:0})),t==="auto"||t==="auto-start"||t==="auto-end"?o.push(W({alignment:t==="auto-start"?"start":t==="auto-end"?"end":null})):e||o.push(P(n?{fallbackPlacements:n}:{})),s&&o.push(G({element:s})),o}function Q(t){return O.includes(t)}function ft(t,e){const n=t.filter(Q);return n.length!==t.length&&console.warn(`${e.tagName}: Invalid value found in: flipPlacements. Try any of these: ${O.map(a=>`"${a}"`).join(", ").trim()}`,{el:e}),n}function w(t,e=!1){const n=["left","right"];return e&&n.reverse(),t.replace(/leading/gi,n[0]).replace(/trailing/gi,n[1])}async function ut(t,e,n=!1){if(!t.open||!e.floatingEl||!e.referenceEl)return;if(Object.assign(e.floatingEl.style,{display:"block",position:e.overlayPositioning??"absolute"}),!l.get(t))return M(t);await(n?X(t):U)(t,e)}function X(t){let e=u.get(t);return e||(e=J(U,I.reposition,{edges:["leading","trailing"]}),u.set(t,e),e)}const Z={top:"",left:"rotate(-90deg)",bottom:"rotate(180deg)",right:"rotate(90deg)"},l=new WeakMap,u=new WeakMap;async function M(t){const{referenceEl:e,floatingEl:n}=t;if(!n.isConnected)return;const a=B;l.set(t,{state:"pending"});let i;const s=a(e,n,()=>{const r=t.reposition();i||(i=r)});return l.set(t,{state:"active",cleanUp:s}),i}function tt(t){const{floatingEl:e}=t;e&&Object.assign(e.style,{display:"",pointerEvents:"",position:"",transform:"",visibility:""})}async function dt(t){const{floatingEl:e,referenceEl:n}=t;if(tt(t),!(!e||!n)&&(et(t),!!t.open))return M(t)}function et(t){const e=l.get(t);e?.state==="active"&&e.cleanUp(),l.delete(t),u.get(t)?.cancel(),u.delete(t)}const F=4,gt=Math.ceil(Math.hypot(F,F));export{ct as F,et as a,lt as b,dt as c,gt as d,rt as e,ft as f,tt as h,ut as r};
