import{O as x,P as v,Q as E,R as Y,S as u,T as m,U as I,V as on,W as w,X as P,Y as rn,Z as o,$ as k,a0 as M,a1 as q,a2 as cn,a3 as un,a4 as Z,a5 as gn,a6 as h,a7 as bn,a8 as l,n as N,a9 as p,aa as fn,ab as ln,ac as B,ad as pn,ae as dn,af as hn,ag as D,ah as O,ai as mn,aj as In,ak as $n,al as Pn,am as Mn,an as Nn,ao as wn,ap as H,aq as Tn,ar as V,as as W}from"./test-Dp3_P59c.js";const _=()=>on.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class vn{constructor(){this.plane=v(),this.origin=N(),this.basis1=N(),this.basis2=N()}}const yn=vn;function $(n=en){return{plane:v(n.plane),origin:E(n.origin),basis1:E(n.basis1),basis2:E(n.basis2)}}function An(n,s,a){const i=Hn.get();return i.origin=n,i.basis1=s,i.basis2=a,i.plane=cn(0,0,0,0),A(i),i}function y(n,s=$()){return G(n.origin,n.basis1,n.basis2,s)}function Sn(n,s){u(s.origin,n.origin),u(s.basis1,n.basis1),u(s.basis2,n.basis2),In(s.plane,n.plane)}function G(n,s,a,i=$()){return u(i.origin,n),u(i.basis1,s),u(i.basis2,a),A(i),zn(i,"fromValues()"),i}function A(n){Y(n.basis2,n.basis1,n.origin,n.plane)}function K(n,s,a){n!==a&&y(n,a);const i=l(o.get(),f(n),s);return p(a.origin,a.origin,i),a.plane[3]-=s,a}function xn(n,s,a){return L(s,a),K(a,R(n,n.origin),a),a}function En(n,s){const a=n.basis1[0],i=n.basis2[1],[t,e]=n.origin;return hn(t-a,e-i,t+a,e+i,s)}function L(n,s=$()){const a=(n[2]-n[0])/2,i=(n[3]-n[1])/2;return P(s.origin,n[0]+a,n[1]+i,0),P(s.basis1,a,0,0),P(s.basis2,0,i,0),rn(0,0,1,0,s.plane),s}function F(n,s,a){return!!dn(n.plane,s,a)&&sn(n,a)}function On(n,s,a){if(F(n,s,a))return a;const i=Q(n,s,o.get());return p(a,s.origin,l(o.get(),s.direction,pn(s.origin,i)/I(s.direction))),a}function Q(n,s,a){const i=T.get();tn(n,s,i,T.get());let t=Number.POSITIVE_INFINITY;for(const e of z){const r=U(n,e,S.get()),g=o.get();if($n(i,r,g)){const c=Pn(o.get(),s.origin,g),b=Math.abs(Mn(m(s.direction,c)));b<t&&(t=b,u(a,g))}}return t===Number.POSITIVE_INFINITY?J(n,s,a):a}function Vn(n,s){return(s-n)/s}function J(n,s,a){if(F(n,s,a))return a;const i=T.get(),t=T.get();tn(n,s,i,t);let e=Number.POSITIVE_INFINITY;for(const r of z){const g=U(n,r,S.get()),c=o.get();if(Nn(i,g,c)){const b=wn(s,c);if(!D(t,c))continue;b<e&&(e=b,u(a,c))}}return C(n,s.origin)<e&&nn(n,s.origin,a),a}function nn(n,s,a){const i=ln(n.plane,s,o.get()),t=B(X(n,n.basis1),i,-1,1,o.get()),e=B(X(n,n.basis2),i,-1,1,o.get());return k(a,p(o.get(),t,e),n.origin),a}function an(n,s,a){const{origin:i,basis1:t,basis2:e}=n,r=k(o.get(),s,i),g=M(t,r),c=M(e,r),b=M(f(n),r);return P(a,g,c,b)}function C(n,s){const a=an(n,s,o.get()),{basis1:i,basis2:t}=n,e=I(i),r=I(t),g=Math.max(Math.abs(a[0])-e,0),c=Math.max(Math.abs(a[1])-r,0),b=a[2];return g*g+c*c+b*b}function _n(n,s){return Math.sqrt(C(n,s))}function jn(n,s){let a=Number.NEGATIVE_INFINITY;for(const i of z){const t=U(n,i,S.get()),e=mn(t,s);e>a&&(a=e)}return Math.sqrt(a)}function Yn(n,s){return D(n.plane,s)&&sn(n,s)}function kn(n,s,a,i){return Un(n,a,i)}function R(n,s){const a=-n.plane[3];return M(f(n),s)-a}function qn(n,s,a,i){const t=R(n,s),e=l(Bn,f(n),a-t);return p(i,s,e),i}function Fn(n,s){return O(n.basis1,s.basis1)&&O(n.basis2,s.basis2)&&O(n.origin,s.origin)}function Cn(n,s,a){return n!==a&&y(n,a),un(d,s),gn(d,d),h(a.basis1,n.basis1,d),h(a.basis2,n.basis2,d),h(w(a.plane),w(n.plane),d),h(a.origin,n.origin,s),bn(a.plane,a.plane,a.origin),a}function Rn(n,s,a,i){return n!==i&&y(n,i),fn(j,s,a),h(i.basis1,n.basis1,j),h(i.basis2,n.basis2,j),A(i),i}function f(n){return w(n.plane)}function Un(n,s,a){switch(s){case V.X:u(a,n.basis1),W(a,a);break;case V.Y:u(a,n.basis2),W(a,a);break;case V.Z:u(a,f(n))}return a}function sn(n,s){const a=k(o.get(),s,n.origin),i=H(n.basis1),t=H(n.basis2),e=m(n.basis1,a),r=m(n.basis2,a);return-e-i<0&&e-i<0&&-r-t<0&&r-t<0}function X(n,s){const a=S.get();return u(a.origin,n.origin),u(a.vector,s),a}function U(n,s,a){const{basis1:i,basis2:t,origin:e}=n,r=l(o.get(),i,s.origin[0]),g=l(o.get(),t,s.origin[1]);p(a.origin,r,g),p(a.origin,a.origin,e);const c=l(o.get(),i,s.direction[0]),b=l(o.get(),t,s.direction[1]);return l(a.vector,p(c,c,b),2),a}function zn(n,s){Math.abs(m(n.basis1,n.basis2)/(I(n.basis1)*I(n.basis2)))>1e-6&&_().warn(s,"Provided basis vectors are not perpendicular"),Math.abs(m(n.basis1,f(n)))>1e-6&&_().warn(s,"Basis vectors and plane normal are not perpendicular"),Math.abs(-m(f(n),n.origin)-n.plane[3])>1e-6&&_().warn(s,"Plane offset is not consistent with plane origin")}function tn(n,s,a,i){const t=f(n);Y(t,s.direction,s.origin,a),Y(w(a),t,s.origin,i)}const en={plane:v(),origin:x(0,0,0),basis1:x(1,0,0),basis2:x(0,1,0)},T=new q(v),S=new q(Tn),Bn=N(),Hn=new q((()=>$())),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=Z(),j=Z(),Xn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:yn,altitudeAt:R,axisAt:kn,cameraFrustumCoverage:Vn,closestPoint:J,closestPointOnSilhouette:Q,copy:y,copyWithoutVerify:Sn,create:$,distance:_n,distance2:C,distanceToSilhouette:jn,elevate:K,equals:Fn,extrusionContainsPoint:Yn,fromAABoundingRect:L,fromValues:G,getExtent:En,intersectRay:F,intersectRayClosestSilhouette:On,normal:f,projectPoint:nn,projectPointLocal:an,rotate:Rn,setAltitudeAt:qn,setExtent:xn,transform:Cn,up:en,updateUnboundedPlane:A,wrap:An},Symbol.toStringTag,{value:"Module"}));export{G as J,A as K,$ as W,y as Z,_n as g,Xn as k,L as t};
