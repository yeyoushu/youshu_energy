import{L as v,r as M}from"./test-DMnSxVQs.js";import{i as C}from"./colorUtils-BIivfTto.js";import{Z as I}from"./FieldsIndex-HhUW4mjA.js";import{h as x}from"./ArcadeExpression-DICBwx3X.js";import{H as O,Y as d,X as k,F as S,a as h,s as N,O as P}from"./utils-y48t8Afq.js";import T from"./callExpressionWithFeature-CZMTqb1s.js";import"./index-BJQUWR-1.js";import"./vendor-CHjNVy30.js";import"./station-DfQHTTxy.js";import"./UnknownTimeZone-BTcI1Sc1.js";import"./TimeOnly-6nuEd6-R.js";import"./enum-Dj4NXxC3.js";import"./defaultCIMValues-eS1WuCTt.js";import"./enums-DCdj6Lab.js";import"./quantizationUtils-DwvMSTst.js";const g=m=>{if(!m)return[0,0,0,0];const{r:e,g:r,b:t,a:i}=m;return[e,r,t,255*i]},o=class o{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let i=!1;for(const s of t)if(s.primitiveName===e.primitiveName){i=!0;break}if(!i)for(const s of r)s.primitiveName===e.primitiveName&&t.push(s)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)o.findApplicableOverrides(i,r,t);if(e.symbolLayers)for(const i of e.symbolLayers)o.findApplicableOverrides(i,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const i of e.effects)o.findApplicableOverrides(i,r,t);if(e.markerPlacement&&o.findApplicableOverrides(e.markerPlacement,r,t),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const i of e.markerGraphics)o.findApplicableOverrides(i,r,t),o.findApplicableOverrides(i.symbol,r,t)}else e.type==="CIMCharacterMarker"?o.findApplicableOverrides(e.symbol,r,t):e.type==="CIMHatchFill"?o.findApplicableOverrides(e.lineSymbol,r,t):e.type==="CIMPictureMarker"&&o.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&O(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=d(e),i=e.primitiveName,s=[];for(const a of r)a.primitiveName===i&&s.push(d(a));return{type:"cim-effect-param",effect:t,overrides:k(s)}}static async resolveSymbolOverrides(e,r,t,i,s,a,c){if(!e?.symbol)return null;let{symbol:p,primitiveOverrides:l}=e;const f=!!l;if(!f&&!i)return p;p=v(p),l=v(l);let y=!0;if(r||(r={attributes:{}},y=!1),f){if(y||(l=l.filter((n=>!n.valueExpressionInfo?.expression.includes("$feature")))),c||(l=l.filter((n=>!n.valueExpressionInfo?.expression.includes("$view")))),l.length>0){const n=S(r.attributes),b={spatialReference:t,fields:n,geometryType:s};await o.createRenderExpressions(l,b),o.evaluateOverrides(l,r,s??"esriGeometryPoint",a,c,new I(n))}o.applyOverrides(p,l)}return i&&o.applyDictionaryTextOverrides(p,r,i,null),p}static async createRenderExpressions(e,r){const t=[];for(const i of e){const s=i.valueExpressionInfo;if(!s||o._expressionToRenderExpression.has(s.expression))continue;const a=x(s.expression,r.spatialReference);t.push(a),a.then((c=>o._expressionToRenderExpression.set(s.expression,c)))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,r,t,i,s,a){const c={$view:{scale:s?.scale}};for(const p of e){p.value&&typeof p.value=="object"&&C(p.value)&&(p.propertyName==="Color"||p.propertyName==="StrokeColor")&&(p.value=g(p.value));const l=p.valueExpressionInfo;if(!l)continue;const f=o._expressionToRenderExpression.get(l.expression);f&&(p.value=T(f,r,c,t,a,i))}}static applyDictionaryTextOverrides(e,r,t,i,s="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const a=e.symbolLayers;if(!a)return;for(const c of a)c&&c.type==="CIMVectorMarker"&&o.applyDictionaryTextOverrides(c,r,t,i,e.type==="CIMTextSymbol"?e.textCase:s)}break;case"CIMVectorMarker":{const a=e.markerGraphics;if(!a)return;for(const c of a)c&&o.applyDictionaryTextOverrides(c,r,t,i)}break;case"CIMMarkerGraphic":{const a=e.textString;if(a&&a.includes("[")){const c=h(a,t);e.textString=N(r,c,i,s)}}}}static applyOverrides(e,r,t,i){if(e.primitiveName){for(const s of r)if(s.primitiveName===e.primitiveName){const a=P(s.propertyName);if(i&&i.push({cim:e,nocapPropertyName:a,value:e[a]}),t){let c=!1;for(const p of t)p.primitiveName===e.primitiveName&&(c=!0);c||t.push(s)}s.value!=null&&(e[a]=s.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)o.applyOverrides(s,r,t,i);if(e.symbolLayers)for(const s of e.symbolLayers)o.applyOverrides(s,r,t,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const s of e.effects)o.applyOverrides(s,r,t,i);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const s of e.markerGraphics)o.applyOverrides(s,r,t,i),o.applyOverrides(s.symbol,r,t,i)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)t.value!==void 0&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map((t=>Number(t)));if(e==="Color"){const t=new M(r).toRgba();return t[3]*=255,t}return r}};o._expressionToRenderExpression=new Map;let u=o;export{u as OverrideHelper};
